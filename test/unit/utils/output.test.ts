import { describe, it, expect } from 'vitest';
import {
  buildPreviewNote,
  buildStructuredResponse,
  buildStructuredTextBlock,
  formatMetadataLine,
  previewList,
  previewRecordEntries,
  safeJSONStringify,
} from '../../../src/utils/output.js';

describe('output utilities', () => {
  it('stringifies bigint and Date payloads safely', () => {
    const payload = { id: 42n, createdAt: new Date('2024-02-02T12:00:00Z') };

    const text = safeJSONStringify(payload, 0);

    expect(text).toContain('"id":"42"');
    expect(text).toContain('"createdAt":"2024-02-02T12:00:00.000Z"');
  });

  it('formats metadata into a compact pipe-delimited line', () => {
    const metadataLine = formatMetadataLine({
      project: 'demo',
      filters: { severity: 'ERROR' },
      empty: '',
      ignored: undefined,
    });

    expect(metadataLine).toBe('project=demo | filters={\n  "severity": "ERROR"\n}');
  });

  it('omits metadata when no printable entries exist', () => {
    expect(formatMetadataLine({ empty: '', nullable: null })).toBeUndefined();
    expect(formatMetadataLine(undefined)).toBeUndefined();
  });

  it('builds structured blocks with metadata, note, payload, and footnotes', () => {
    const block = buildStructuredTextBlock({
      title: '# Latest Findings',
      metadata: { region: 'us-central1' },
      data: { status: 'ok' },
      dataLabel: 'Payload',
      note: 'Preview data only.',
      footnote: '*Generated by MCP*',
    });

    const sections = block.split('\n\n');
    expect(sections[0]).toBe('# Latest Findings');
    expect(sections[1]).toBe('region=us-central1');
    expect(sections).toEqual(
      expect.arrayContaining(['Preview data only.', '*Generated by MCP*'])
    );
    expect(block).toContain('```json');
    expect(block).toContain('"status": "ok"');
  });

  it('builds preview notes depending on totals, omissions, and limits', () => {
    expect(
      buildPreviewNote({ total: 0, displayed: 0, label: 'rows', emptyMessage: 'No rows found.' })
    ).toBe('No rows found.');

    expect(
      buildPreviewNote({ total: 5, displayed: 5, label: 'rows' })
    ).toBeUndefined();

    expect(
      buildPreviewNote({ total: 12, displayed: 5, label: 'rows', limit: 5 })
    ).toBe('Showing 5 of 12 rows (preview limit 5).');
  });

  it('merges preview notes, manual notes, and additional notes', () => {
    const response = buildStructuredResponse({
      title: '# Query Summary',
      data: { items: [1, 2, 3] },
      preview: { total: 10, displayed: 3, label: 'rows' },
      note: 'Top rows only.',
      additionalNotes: ['Sorted by latency.'],
    });

    expect(response).toContain('Showing 3 of 10 rows');
    expect(response).toContain('Top rows only.');
    expect(response).toContain('Sorted by latency.');
  });

  it('returns preview slices for arrays and maps omission counts correctly', () => {
    const { displayed, omitted } = previewList([1, 2, 3, 4], 2);
    expect(displayed).toEqual([1, 2]);
    expect(omitted).toBe(2);

    const noOmission = previewList(['a'], 5);
    expect(noOmission.displayed).toEqual(['a']);
    expect(noOmission.omitted).toBe(0);
  });

  it('previews record entries with omission tracking', () => {
    const { displayed, omitted } = previewRecordEntries(
      { a: 1, b: 2, c: 3 },
      2,
    );
    expect(displayed).toEqual({ a: 1, b: 2 });
    expect(omitted).toBe(1);

    const empty = previewRecordEntries(undefined, 3);
    expect(empty.displayed).toEqual({});
    expect(empty.omitted).toBe(0);
  });
});
